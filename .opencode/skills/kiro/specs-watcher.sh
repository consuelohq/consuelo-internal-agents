#!/bin/bash
#
# Kiro Specs Watcher
#
# Polls Linear for kiro-tagged tasks and spawns Kiro sessions to code them.
#
# Usage:
#   .opencode/skills/kiro/specs-watcher.sh           # Run once
#   .opencode/skills/kiro/specs-watcher.sh --daemon  # Run continuously with polling
#   .opencode/skills/kiro/specs-watcher.sh --setup  # Setup Linear API cache
#
# Cron setup (every 30 minutes):
#   */30 * * * * /Users/kokayi/Dev/claude-agent-workflow/.opencode/skills/kiro/specs-watcher.sh
#

# Load configuration
if [ -f "$(dirname "${BASH_SOURCE[0]}")/config.sh" ]; then
    source "$(dirname "${BASH_SOURCE[0]}")/config.sh"
fi

# Load Linear API
if [ -f "$(dirname "${BASH_SOURCE[0]}")/linear-api-kiro.sh" ]; then
    source "$(dirname "${BASH_SOURCE[0]}")/linear-api-kiro.sh"
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# State
RUN_ID=""
RUN_BRANCH=""
PROCESSED_COUNT=0
FAILED_COUNT=0

# =============================================================================
# LOGGING
# =============================================================================

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# =============================================================================
# STATE MANAGEMENT
# =============================================================================

save_state() {
    cat > "$STATE_FILE" << EOF
{
  "run_id": "$RUN_ID",
  "last_run": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "processed": $PROCESSED_COUNT,
  "failed": $FAILED_COUNT
}
EOF
}

load_state() {
    if [ -f "$STATE_FILE" ]; then
        local last_run
        last_run=$(cat "$STATE_FILE" | jq -r '.last_run' 2>/dev/null)
        if [ -n "$last_run" ] && [ "$last_run" != "null" ]; then
            log_info "Last run: $last_run"
        fi
    fi
}

# =============================================================================
# GITHUB HELPERS
# =============================================================================

# Create a branch for the task
create_task_branch() {
    local issue_id="$1"
    local issue_ident="$2"
    local title="$3"

    # Sanitize title for branch name
    local sanitized
    sanitized=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')

    # Generate short hash from issue + timestamp
    local hash
    hash=$(echo "$issue_id$(date +%s)" | md5 2>/dev/null || echo "$issue_id$(date +%s)" | md5sum 2>/dev/null | cut -d' ' -f1)
    hash=$(echo "$hash" | head -c 6)

    local branch_name="kiro/${sanitized}-${hash}"

    log_info "Creating branch: $branch_name" >&2

    # Create branch via github-dev
    local result
    result=$(python3 "$GITHUB_DEV" create-branch "$branch_name" 2>&1)

    if [ $? -eq 0 ]; then
        echo "$branch_name"
        return 0
    else
        log_error "Failed to create branch: $result" >&2
        return 1
    fi
}

# Create PR from branch
create_task_pr() {
    local branch_name="$1"
    local issue_ident="$2"
    local title="$3"

    # Get the commit messages
    local commits
    commits=$(python3 "$GITHUB_DEV" log --oneline -10 2>/dev/null | head -5)

    # Determine PR body
    local body="Kiro implementation for $issue_ident

## Changes
$commits

## Notes
- Auto-generated by specs-watcher"
    # Create PR via github-dev
    local pr_result
    pr_result=$(python3 "$GITHUB_DEV" create-pr \
        --title "$title" \
        --body "$body" \
        --base "$BASE_BRANCH" \
        --label kiro 2>&1)

    if [ $? -eq 0 ]; then
        log_success "PR created: $pr_result"
        echo "$pr_result"
        return 0
    else
        log_error "Failed to create PR: $pr_result"
        return 1
    fi
}

# =============================================================================
# KIRO EXECUTION
# =============================================================================

# Run a single kiro session for a task
run_kiro_session() {
    local issue_id="$1"
    local issue_ident="$2"
    local title="$3"
    local description="$4"
    local branch_name="$5"

    log_info "Starting kiro session for $issue_ident: $title"

    # Move issue to In Progress
    local in_progress_state
    in_progress_state=$(linear_get_state_id "$LINEAR_STATE_IN_PROGRESS")
    if [ -n "$in_progress_state" ] && [ "$in_progress_state" != "null" ]; then
        linear_update_state "$issue_id" "$in_progress_state"
    fi

    # Build task description with full context
    local task_desc="$title

$description

---
Linear Issue: $issue_ident
Branch: $branch_name
"

    # Run kiro agent (spawns fresh kiro ACP session)
    local kiro_result
    kiro_result=$(python3 "$KIRO_AGENT" run \
        --branch "$branch_name" \
        --linear "$issue_ident" \
        "$task_desc" 2>&1)

    local exit_code=$?
    local result_json
    result_json=$(echo "$kiro_result" | tail -1)

    # Check if kiro created specs or coded
    local session_type
    session_type=$(echo "$result_json" | jq -r '.type // "unknown"' 2>/dev/null)

    if [ "$session_type" = "specs" ]; then
        log_info "Kiro created sub-specs for $issue_ident (complex task)"
        # Keep in In Progress or move to In Review?
        # Specs created means kiro didn't code, so keep as In Progress
        # until sub-specs are coded
    elif [ "$session_type" = "code" ] || [ $exit_code -eq 0 ]; then
        log_success "Kiro finished coding for $issue_ident"

        # Create PR
        local pr_url
        pr_url=$(create_task_pr "$branch_name" "$issue_ident" "$title")

        if [ -n "$pr_url" ]; then
            # Move issue to In Review
            local in_review_state
            in_review_state=$(linear_get_state_id "$LINEAR_STATE_IN_REVIEW")
            if [ -n "$in_review_state" ] && [ "$in_review_state" != "null" ]; then
                linear_update_state "$issue_id" "$in_review_state"
            fi

            # Add PR comment
            local pr_num
            pr_num=$(echo "$pr_url" | grep -oE '[0-9]+$' | tail -1)
            if [ -n "$pr_num" ]; then
                linear_add_comment "$issue_id" "Kiro implementation PR: $pr_url"
            fi

            # Slack notification
            send_slack ":robot: Kiro completed task *$issue_ident*\n$title\nPR: $pr_url" "#36a64f"
        fi
    else
        log_error "Kiro failed for $issue_ident"
        send_slack ":x: Kiro failed on *$issue_ident*\n$title" "#dc2626"
        return 1
    fi

    echo "$kiro_result"
    return 0
}

# =============================================================================
# MAIN POLL LOOP
# =============================================================================

poll_for_tasks() {
    log_info "Polling for kiro-tagged tasks..."

    # Fetch issues
    local issues
    issues=$(linear_get_kiro_issues)

    if [ -z "$issues" ] || [ "$issues" = "[]" ]; then
        log_info "No kiro tasks found"
        return 0
    fi

    local issue_count
    issue_count=$(echo "$issues" | wc -l | tr -d ' ')
    log_info "Found $issue_count kiro task(s)"

    # Process each issue
    echo "$issues" | while IFS= read -r issue_json; do
        # Skip empty lines
        [ -z "$issue_json" ] && continue

        # Parse issue details
        local issue_id issue_ident title description
        issue_id=$(echo "$issue_json" | jq -r '.id' 2>/dev/null)
        issue_ident=$(echo "$issue_json" | jq -r '.identifier' 2>/dev/null)
        title=$(echo "$issue_json" | jq -r '.title' 2>/dev/null)
        description=$(echo "$issue_json" | jq -r '.description // ""' 2>/dev/null)

        # Skip if missing required fields
        [ -z "$issue_id" ] || [ "$issue_id" = "null" ] && continue
        [ -z "$title" ] || [ "$title" = "null" ] && continue

        log_info "Processing $issue_ident: $title"

        # Create branch
        local branch_name
        branch_name=$(create_task_branch "$issue_id" "$issue_ident" "$title")
        if [ $? -ne 0 ] || [ -z "$branch_name" ]; then
            log_error "Skipping $issue_ident - branch creation failed"
            FAILED_COUNT=$((FAILED_COUNT + 1))
            save_state
            continue
        fi

        # Run kiro session
        run_kiro_session "$issue_id" "$issue_ident" "$title" "$description" "$branch_name"
        local result=$?

        PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
        save_state

        # Check max tasks limit
        if [ "$MAX_TASKS_PER_RUN" -gt 0 ] && [ "$PROCESSED_COUNT" -ge "$MAX_TASKS_PER_RUN" ]; then
            log_info "Reached max tasks limit ($MAX_TASKS_PER_RUN)"
            break
        fi

        # Continue to next issue even if this one failed
    done
}

# =============================================================================
# ENTRY POINT
# =============================================================================

main() {
    # Handle commands
    case "${1:-}" in
        --setup|--setup-cache)
            linear_setup_cache
            exit $?
            ;;
        --daemon|--continuous)
            log_info "Starting kiro specs watcher in daemon mode..."
            log_info "Polling interval: ${POLL_INTERVAL}s"
            ;;
        --help|-h)
            echo "Kiro Specs Watcher"
            echo ""
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --setup, --setup-cache  Setup Linear API and cache IDs"
            echo "  --daemon, --continuous  Run continuously with polling"
            echo "  --help, -h              Show this help"
            echo ""
            echo "Environment Variables:"
            echo "  LINEAR_API_KEY          Your Linear API key"
            echo "  LINEAR_TEAM_ID          Your Linear team ID"
            echo "  SLACK_WEBHOOK_URL       Slack webhook for notifications"
            echo "  POLL_INTERVAL           Polling interval in seconds (default: 1800)"
            echo ""
            echo "Examples:"
            echo "  $0 --setup                           # Setup Linear API"
            echo "  $0                                   # Run once"
            echo "  $0 --daemon                          # Run continuously"
            echo "  POLL_INTERVAL=600 $0 --daemon        # Poll every 10 minutes"
            echo ""
            exit 0
            ;;
    esac

    # Load previous state
    load_state

    # Check API
    if ! linear_check_api 2>/dev/null; then
        log_error "Linear API check failed. Run with --setup to configure."
        exit 1
    fi

    # Run once or daemon
    if [ "${1:-}" = "--daemon" ] || [ "${1:-}" = "--continuous" ]; then
        while true; do
            poll_for_tasks
            log_info "Sleeping for ${POLL_INTERVAL}s..."
            sleep "$POLL_INTERVAL"
        done
    else
        poll_for_tasks
        log_info "Done. Processed: $PROCESSED_COUNT, Failed: $FAILED_COUNT"
    fi
}

main "$@"
